<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Hosting • plumber</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/Source_Sans_Pro-0.4.9/font.css" rel="stylesheet">
<link href="../deps/Source_Code_Pro-0.4.9/font.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Hosting">
</head>
<body>
    <a href="#container" class="visually-hidden-focusable">Skip to content</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-none" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">plumber</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.3.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/introduction.html">Introduction</a></li>
    <li><a class="dropdown-item" href="../articles/quickstart.html">Quickstart</a></li>
    <li><a class="dropdown-item" href="../articles/routing-and-input.html">Routing &amp; Input</a></li>
    <li><a class="dropdown-item" href="../articles/rendering-output.html">Rendering Output</a></li>
    <li><a class="dropdown-item" href="../articles/execution-model.html">Runtime</a></li>
    <li><a class="dropdown-item" href="../articles/security.html">Security</a></li>
    <li><a class="dropdown-item" href="../articles/hosting.html">Hosting</a></li>
    <li><a class="dropdown-item" href="../articles/programmatic-usage.html">Programmatic Usage</a></li>
    <li><a class="dropdown-item" href="../articles/annotations.html">Annotations reference</a></li>
    <li><a class="dropdown-item" href="../articles/tips-and-tricks.html">Tips &amp; Tricks</a></li>
    <li><a class="dropdown-item" href="../articles/migration.html">Migration Guide</a></li>
  </ul>
</li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-news" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">News</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-news">
<li><h6 class="dropdown-header" data-toc-skip>Releases</h6></li>
    <li><a class="external-link dropdown-item" href="https://blog.rstudio.com/2021/03/29/plumber-v1-1-0/">Version 1.1.0</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><a class="dropdown-item" href="../news/index.html">Changelog</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/rstudio/plumber/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article" id="container">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.svg" class="logo" alt=""><h1>Hosting</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/rstudio/plumber/blob/rc-v1.3.0/vignettes/hosting.Rmd" class="external-link"><code>vignettes/hosting.Rmd</code></a></small>
      <div class="d-none name"><code>hosting.Rmd</code></div>
    </div>

    
    
<p>Once you have developed your Plumber API, the next step is to find a
way to host it. If you haven’t dealt with hosting an application on a
server before, you may be tempted to run the <code>run()</code> command
from an interactive session on your development machine (either your
personal desktop or an RStudio Server instance) and direct traffic
there. This is a dangerous idea for a number of reasons:</p>
<ol style="list-style-type: decimal">
<li>Your development machine likely has a dynamic IP address. This means
that clients may be able to reach you at that address today, but it will
likely break on you in the coming weeks/months.</li>
<li>Networks may leverage firewalls to block incoming traffic to certain
networks and machines. Again, it may appear that everything is working
for you locally, but other users elsewhere in the network or external
clients may not be able to connect to your development machine.</li>
<li>If your Plumber process crashes (for instance, due to your server
running out of memory), the method of running Plumber will not
automatically restart the crashed service for you. This means that your
API will be offline until you manually login and restart it. Likewise if
your development machine gets rebooted, your API will not automatically
be started when the machine comes back online.</li>
<li>This technique relies on having your clients specify a port number
manually. Non-technical users may be tripped up by this; some of the
other techniques do not require clients specifying the port for an
API.</li>
<li>This approach will eternally run one R process for your API. Some of
the other approaches will allow you to load-balance traffic between
multiple R processes to handle more requests. <a href="#posit-connect">Posit Connect</a> will even dynamically scale the
number of running processes for you so that your API isn’t consuming
more system resources than is necessary.</li>
<li>Most importantly, serving public requests from your development
environment can be a security hazard. Ideally, you should separate your
development instances from the servers that are accessible by
others.</li>
</ol>
<p>For these reasons and more, you should consider setting up a separate
server on which you can host your Plumber APIs. There are a variety of
options that you can consider.</p>
<div class="section level2">
<h2 id="posit-connect">Posit Connect<a class="anchor" aria-label="anchor" href="#posit-connect"></a>
</h2>
<p><a href="https://posit.co/products/enterprise/connect/" class="external-link">Posit
Connect</a> is an enterprise publishing platform from Posit. It supports
push-button publishing from the RStudio IDE of a variety of R content
types including Plumber APIs. Unlike all the other options listed here,
Posit Connect automatically manages the dependent packages and files
your API has and recreates an environment closely mimicking your local
development environment on the server.</p>
<p>Posit Connect automatically manages the number of R processes
necessary to handle the current load and balances incoming traffic
across all available processes. It can also shut down idle processes
when they’re not in use. This allows you to run the appropriate number
of R processes to scale your capacity to accommodate the current
load.</p>
</div>
<div class="section level2">
<h2 id="digitalocean">DigitalOcean<a class="anchor" aria-label="anchor" href="#digitalocean"></a>
</h2>
<p><a href="https://m.do.co/c/add0b50f54c4" class="external-link">DigitalOcean</a> is an
easy-to-use Cloud Computing provider. They offer a simple way to spin up
a Linux virtual machine and access it remotely. You can choose what size
machine you want to run – with options ranging from small machines with
512MB of RAM for a few dollars a month up to large machines with dozens
of GB of RAM – and only pay for it while it’s online.</p>
<p>To deploy your Plumber API to DigitalOcean, please check out the
<code>plumber</code> companion package <a href="https://github.com/meztez/plumberDeploy" class="external-link"><code>plumberDeploy</code></a>.</p>
</div>
<div class="section level2">
<h2 id="docker">Docker (Basic)<a class="anchor" aria-label="anchor" href="#docker"></a>
</h2>
<p><a href="https://docker.io" class="external-link">Docker</a> is a platform built on top of
Linux Containers that allow you to run processes in an isolated
environment; that environment might have certain resources/software
pre-configured or may emulate a particular Linux environment like Ubuntu
14.04 or CentOS 7.3.</p>
<p>We won’t delve into the details of Docker or how to setup or install
everything on your system. Docker provides some <a href="https://docs.docker.com/" class="external-link">great resources</a> for those who are
looking to get started. Here we’ll assume that you have Docker installed
and you’re familiar with the basic commands required to spin up a
container.</p>
<p>In this article, we’ll take advantage of the <a href="https://hub.docker.com/r/rstudio/plumber/" class="external-link">rstudio/plumber</a>
Docker image that bundles a recent version of R with the most recent
version of plumber pre-installed (the underlying R image is courtesy of
the <a href="https://github.com/rocker-org/rocker" class="external-link">rocker</a> project).
You can get this image with a</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="ex">docker</span> pull rstudio/plumber</span></code></pre></div>
<p>Remember that this will get you the current snapshot of Plumber and
will continue to use that image until you run <code>pull</code>
again.</p>
<div class="section level3">
<h3 id="default-dockerfile">Default Dockerfile<a class="anchor" aria-label="anchor" href="#default-dockerfile"></a>
</h3>
<p>We’ll start by just running a single Plumber application in Docker
just to see things at work. By default, the <code>rstudio/plumber</code>
image will take the first argument after the image name as the name of
the file that you want to <code><a href="../reference/plumb.html">plumb()</a></code> and serve on port
<code>8000</code>. So right away you can run one of the examples that’s
included in plumber as it is already installed on the image.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">--rm</span> <span class="at">-p</span> 8000:8000 rstudio/plumber</span></code></pre></div>
<p>which is the same as:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">--rm</span> <span class="at">-p</span> 8000:8000 rstudio/plumber <span class="dt">\</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>  /usr/local/lib/R/site-library/plumber/plumber/04-mean-sum/plumber.R</span></code></pre></div>
<ul>
<li>
<code>docker run</code> tells Docker to run a new container</li>
<li>
<code>--rm</code> tells Docker to clean-up after the container when
it’s done</li>
<li>
<code>-p 8000:8000</code> says to map port 8000 from the plumber
container (which is where we’ll run the server) to port 8000 of your
local machine</li>
<li>
<code>rstudio/plumber</code> is the name of the image we want to
run</li>
<li>
<code>/usr/local/lib/R/site-library/plumber/plumber/03-mean-sum/plumber.R</code>
is the path <strong>inside of the Docker container</strong> to the
Plumber file you want to host. You’ll note that you do not need plumber
installed on your host machine for this to work, nor does the path
<code>/usr/local/...</code> need to exist on your host machine. This
references the path inside of the docker container where the R file you
want to <code><a href="../reference/plumb.html">plumb()</a></code> can be found. This <code>mean-sum</code>
path is the default path that the image uses if you don’t specify one
yourself.</li>
</ul>
<p>This will ask Plumber to <code>plumb</code> and <code>run</code> the
file you specified on port 8000 of that new container. Because you used
the <code>-p</code> argument, port 8000 of your local machine will be
forwarded into your container. You can test this by running this on the
machine where Docker is running: <code>curl localhost:8000/mean</code>,
or if you know the IP address of the machine where Docker is running,
you could visit it in a web browser. The <code>/mean</code> path is one
that’s defined in the plumber file we just specified – you should get an
single number in an array back (<code>[-0.1993]</code>).</p>
<p>If that works, you can try using one of your own plumber files in
this arrangement. Keep in mind that the file you want to run
<strong>must</strong> be available inside of the container and you must
specify the path to that file as it exists inside of the container. Keep
it simple for now – use a plumber file that doesn’t require any
additional R packages or depend on any other files outside of the
plumber definition.</p>
<p>For instance if you have a plumber file saved in your current
directory called <code>api.R</code>, you could use the following
command</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">--rm</span> <span class="at">-p</span> 8000:8000 <span class="at">-v</span> <span class="kw">`</span><span class="bu">pwd</span><span class="kw">`</span>/api.R:/plumber.R rstudio/plumber /plumber.R</span></code></pre></div>
<p>You’ll notice that we used the <code>-v</code> argument to specify a
“volume” that should be mapped from our host machine into the Docker
container. We defined that the location of that file should be at
<code>/plumber.R</code>, so that’s the argument we give last to tell the
container where to look for the plumber definition. You can use this
same technique to share a whole directory instead of just passing in a
single R file; this approach is useful if your Plumber API depends on
other files.</p>
<p>You can also use the <code>rstudio/plumber</code> image just like you
use any other. For example, if you want to start a container based on
this image and poke around in a bash shell:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">-it</span> <span class="at">--rm</span> <span class="at">--entrypoint</span> /bin/bash rstudio/plumber</span></code></pre></div>
<p>This can be a handy way to debug problems. Prepare the command that
you think should work then add <code>--entrypoint /bin/bash</code>
before <code>rstudio/plumber</code> and explore a bit. Alternatively,
you can try to run the R process and spawn the plumber application
yourself and see where things go wrong (often a missing package or
missing file).</p>
</div>
<div class="section level3">
<h3 id="custom-dockerfiles">Custom Dockerfiles<a class="anchor" aria-label="anchor" href="#custom-dockerfiles"></a>
</h3>
<p>You can build upon the <code>rstudio/plumber</code> image and build
your own Docker image by writing your own Dockerfile. Dockerfiles have a
vast array of options and possible configurations, so <a href="https://docs.docker.com/engine/reference/builder/" class="external-link">see the
official docs</a> if you want to learn more about any of these
options.</p>
<p>A couple of commands that are relevant here:</p>
<ul>
<li>
<code>RUN</code> runs a command and persists the side-effects in the
Docker image you’re building. So if you want to build a new image that
has the <code>broom</code> package, you could add a line in your
Dockerfile that says <code>RUN R -e "install.packages('broom')"</code>
which would make the <code>broom</code> package available in your new
Docker image.</li>
<li>
<code>ENTRYPOINT</code> is the command to run when starting the
image. <code>rstudio/plumber</code> specifies an entrypoint that starts
R, <code><a href="../reference/plumb.html">plumb()</a></code>s a file, then <code>run()</code>s the router. If
you want to change how plumber starts, or run some extra commands (like
add a global processor) before you run the router, you’ll need to
provide a custom <code>ENTRYPOINT</code>.</li>
<li>
<code>CMD</code> these are the default arguments to provide to
<code>ENTRYPOINT</code>. <code>rstudio/plumber</code> uses only the
first argument as the name of the file that you want to
<code><a href="../reference/plumb.html">plumb()</a></code>.</li>
</ul>
<p>So your custom Dockerfile could be as simple as:</p>
<pre><code>FROM rstudio/plumber
LABEL org.opencontainers.image.authors="Docker User &lt;docker@user.org&gt;"

RUN R -e "install.packages('broom')"

CMD ["/app/plumber.R"]</code></pre>
<p>This Dockerfile would just extend the <code>rstudio/plumber</code>
image in two ways. First, it <code>RUN</code>s one additional command to
install the <code>broom</code> package. Second, it customizes the
default <code>CMD</code> argument that will be used when running the
image. In this case, you would be expected to mount a Plumber
application into the container at <code>/app/plumber.R</code></p>
<p>You could then build your custom Docker image from this Dockerfile
using the command <code>docker build -t mycustomdocker .</code> (where
<code>.</code> – the current directory – is the directory where that
Dockerfile is stored).</p>
<p>Then you’d be able to use
<code>docker run --rm -v</code>pwd<code>:/app mycustomdocker</code> to
run your custom image, passing in your application’s directory as a
volume mounted at <code>/app</code>.</p>
</div>
<div class="section level3">
<h3 id="automatically-run-on-restart">Automatically Run on Restart<a class="anchor" aria-label="anchor" href="#automatically-run-on-restart"></a>
</h3>
<p>If you want your container to start automatically when your machine
is booted, you can use the <code>--restart</code> parameter for
<code>docker run</code>.</p>
<p><code>docker run -p 1234:8000 -dit --restart=unless-stopped myCustomDocker</code>
would run the custom image you created above automatically every time
your machine boots and expose the plumber service on port
<code>1234</code> of your host machine, unless the container is
explicitly stopped. Like all other hosting options, you’ll need to make
sure that your firewall allows connections on port <code>1234</code> if
you want others to be able to access your service.</p>
</div>
</div>
<div class="section level2">
<h2 id="docker-advanced">Docker (Advanced)<a class="anchor" aria-label="anchor" href="#docker-advanced"></a>
</h2>
<p>If you already have a <a href="#docker">basic Docker instance</a>
running, you may be interested in more advanced configurations capable
of hosting multiple plumber applications on a single server and even
load-balancing across multiple plumber processes.</p>
<p>In order to coordinate and run multiple Plumber processes on one
server, <strong>you should install <code>docker-compose</code> on your
system.</strong> This is not included with some installations of Docker,
so you will need to <a href="https://docs.docker.com/compose/install/" class="external-link">follow these
instructions</a> if you are not currently able to run
<code>docker-compose</code> on the command-line. Docker Compose helps
orchestrate multiple Docker containers. If you’re planning to run more
than one Plumber process, you’ll want to use Docker Compose to keep them
all alive and route traffic between them.</p>
<div class="section level3">
<h3 id="multiple-plumber-applications">Multiple Plumber Applications<a class="anchor" aria-label="anchor" href="#multiple-plumber-applications"></a>
</h3>
<p>We’ll use Docker Compose to help us organize multiple Plumber
processes. We won’t go into detail about how to use Docker Compose, so
if you’re new you should familiarize yourself using the <a href="https://docs.docker.com/compose" class="external-link">official docs</a>.</p>
<p>You should define a Docker Compose configuration that defines the
behavior of every Plumber application that you want to run. You’ll first
want to setup a Dockerfile that defines the desired behavior for each of
your applications (as <a href="#custom-dockerfiles">we outlined
previously</a>. You could use a <code>docker-compose.yml</code>
configuration like the following:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="fu">services</span><span class="kw">:</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="at">  </span><span class="fu">app1</span><span class="kw">:</span></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a><span class="at">    </span><span class="fu">build</span><span class="kw">:</span><span class="at"> ./app1/</span></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a><span class="at">    </span><span class="fu">volumes</span><span class="kw">:</span></span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a><span class="at">     </span><span class="kw">-</span><span class="at"> ./data:/data</span></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a><span class="at">     </span><span class="kw">-</span><span class="at"> ./app1:/app</span></span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a><span class="at">    </span><span class="fu">restart</span><span class="kw">:</span><span class="at"> always</span></span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a><span class="at">    </span><span class="fu">ports</span><span class="kw">:</span></span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a><span class="at">     </span><span class="kw">-</span><span class="at"> </span><span class="st">"7000:8000"</span></span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a><span class="at">  </span><span class="fu">app2</span><span class="kw">:</span></span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> rstudio/plumber</span></span>
<span id="cb7-12"><a href="#cb7-12" tabindex="-1"></a><span class="at">    </span><span class="fu">command</span><span class="kw">:</span><span class="at"> /app/plumber.R</span></span>
<span id="cb7-13"><a href="#cb7-13" tabindex="-1"></a><span class="at">    </span><span class="fu">volumes</span><span class="kw">:</span></span>
<span id="cb7-14"><a href="#cb7-14" tabindex="-1"></a><span class="at">     </span><span class="kw">-</span><span class="at"> ../app2:/app</span></span>
<span id="cb7-15"><a href="#cb7-15" tabindex="-1"></a><span class="at">    </span><span class="fu">restart</span><span class="kw">:</span><span class="at"> always</span></span>
<span id="cb7-16"><a href="#cb7-16" tabindex="-1"></a><span class="at">    </span><span class="fu">ports</span><span class="kw">:</span></span>
<span id="cb7-17"><a href="#cb7-17" tabindex="-1"></a><span class="at">     </span><span class="kw">-</span><span class="at"> </span><span class="st">"7001:8000"</span></span></code></pre></div>
<p>More detail on what each of these options does and what other options
exist can be found <a href="https://docs.docker.com/compose/compose-file/" class="external-link">here</a>. This
configuration defines two Docker containers that should run
<code>app1</code> and <code>app2</code>. The associated files in this
case are laid out on disk as follows:</p>
<pre><code>docker-compose.yml
app1
├── Dockerfile
├── api.R
app2
├── plumber.R
data
├── data.csv</code></pre>
<p>You can see that app2 is the simpler of the two apps; it just has the
plumber definition that should be run through <code><a href="../reference/plumb.html">plumb()</a></code>. So
we merely use the default plumber Docker image as its
<code>image</code>, and then customize the <code>command</code> to
specify where the Plumber API definition can be found in the container.
Since we’re mapping our host’s <code>./app2</code> to <code>/app</code>
inside of the container, the definition would be found in
<code>/app/plumber.R</code>. We specify that it should
<code>always</code> restart if anything ever happens to the container,
and we export port <code>8000</code> from the container to port
<code>7001</code> on the host.</p>
<p><code>app1</code> is our more complicated app. It has some extra data
in another directory that needs to be loaded, and it has a custom
Dockerfile. This could be because it has additional R packages or system
dependencies that it requires.</p>
<p>If you now run <code>docker-compose up</code>, Docker Compose will
build the referenced images in your config file and then run them.
You’ll find that <code>app1</code> is available on port
<code>7000</code> of the machine running Docker Compose, and
<code>app2</code> is available on port <code>7001</code>. If you want
these APIs to run in the background and survive restarts of your server,
you can use the <code>-d</code> switch just like with
<code>docker run</code>.</p>
</div>
<div class="section level3">
<h3 id="multiple-applications-on-one-port">Multiple Applications on One Port<a class="anchor" aria-label="anchor" href="#multiple-applications-on-one-port"></a>
</h3>
<p>It may desirable to run all of your Plumber services on a standard
port like <code>80</code> (for HTTP) or <code>443</code> (for HTTPS). In
that case, you’d prefer to have a router running on port <code>80</code>
that can send traffic to the appropriate Plumber API by distinguishing
based on a path prefix. Requests for <code>myserver.com/app1/</code>
could be sent to the <code>app1</code> container, and
<code>myserver.org/app2/</code> could target the <code>app2</code>
container, but both paths would be available on port 80 on your
server.</p>
<p>In order to do this, we can use another Docker container running <a href="https://www.nginx.com/" class="external-link">nginx</a> which is configured to route
traffic between the two Plumber containers. We’d add the following entry
to our <code>docker-compose.yml</code> below the app containers we
already have defined.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="at">  </span><span class="fu">nginx</span><span class="kw">:</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> nginx:1.9</span></span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a><span class="at">    </span><span class="fu">ports</span><span class="kw">:</span></span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a><span class="at">     </span><span class="kw">-</span><span class="at"> </span><span class="st">"80:80"</span></span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a><span class="at">    </span><span class="fu">volumes</span><span class="kw">:</span></span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a><span class="at">     </span><span class="kw">-</span><span class="at"> ./nginx.conf:/etc/nginx/nginx.conf:ro</span></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a><span class="at">    </span><span class="fu">restart</span><span class="kw">:</span><span class="at"> always</span></span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a><span class="at">    </span><span class="fu">depends_on</span><span class="kw">:</span></span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a><span class="at">     </span><span class="kw">-</span><span class="at"> app1</span></span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a><span class="at">     </span><span class="kw">-</span><span class="at"> app2</span></span></code></pre></div>
<p>This uses the nginx Docker image that will be downloaded for you. In
order to run nginx in a meaningful way, we have to provide a
configuration file and place it in <code>/etc/nginx/nginx.conf</code>,
which we do by mounting a local file at that location on the
container.</p>
<p>A basic nginx config file could look something like the
following:</p>
<pre><code>events {
  worker_connections  4096;  ## Default: 1024
}

http {
        default_type application/octet-stream;
        sendfile     on;
        tcp_nopush   on;
        server_names_hash_bucket_size 128; # this seems to be required for some vhosts

        server {
                listen 80 default_server;
                listen [::]:80 default_server ipv6only=on;

                root /usr/share/nginx/html;
                index index.html index.htm;

                server_name MYSERVER.ORG;

                location /app1/ {
                        proxy_pass http://app1:8000/;
                        proxy_set_header Host $host;
                }

                location /app2/ {
                        proxy_pass http://app2:8000/;
                        proxy_set_header Host $host;
                }


                location ~ /\.ht {
                        deny all;
                }
        }
}</code></pre>
<p>You should set the <code>server_name</code> parameter above to be
whatever the public address is of your server. You can save this file as
<code>nginx.conf</code> in the same directory as your Compose config
file.</p>
<p>Docker Compose is intelligent enough to know to route traffic for
<code>http://app1:8000/</code> to the <code>app1</code> container, port
<code>8000</code>, so we can leverage that in our config file. Docker
containers are able to contact each other on their non-public ports, so
we can go directly to port <code>8000</code> for both containers. This
proxy configuration will trim the prefix off of the request before it
sends it on to the applications, so your applications don’t need to know
anything about being hosted publicly at a URL that includes the
<code>/app1/</code> or <code>/app2/</code> prefixes.</p>
<p>We should also get rid of the previous port mappings to ports
<code>7000</code> and <code>7001</code> on our other applications, as we
don’t want to expose our APIs on those ports anymore.</p>
<p>If you now run <code>docker compose up</code> again, you’ll see your
two application servers running but now have a new nginx server running,
as well. And you’ll find that if you visit your server on port 80,
you’ll see the “welcome to Nginx!” page. If you access
<code>/app1</code> you’ll be sent to <code>app1</code> just like we had
hoped.</p>
</div>
<div class="section level3">
<h3 id="load-balancing">Load Balancing<a class="anchor" aria-label="anchor" href="#load-balancing"></a>
</h3>
<p>If you’re expecting a lot of traffic on one application or have an
API that’s particularly computationally complex, you may want to
distribute the load across multiple R processes running the same Plumber
application. Thankfully, we can use Docker Compose for this, as
well.</p>
<p>First, we’ll want to create multiple instances of the same
application. This is easily accomplished with the
<code>docker-compose scale</code> command. You simply run
<code>docker-compose scale app1=3</code> to run three instances of
<code>app1</code>. Now we just need to load balance traffic across these
three instances.</p>
<p>You could setup the nginx configuration that we already have to
balance traffic across this pool of workers, but you would need to
manually re-configure and update your nginx instance every time that you
need to scale the number up or down, which might be a hassle. Luckily,
there’s a more elegant solution.</p>
<p>We can use the <a href="https://github.com/docker/dockercloud-haproxy" class="external-link">dockercloud/haproxy</a>
Docker image to automatically balance HTTP traffic across a pool of
workers. This image is intelligent enough to listen for workers in your
pool arriving or leaving and will automatically remove/add these
containers into their pool. Let’s add a new container into our
configuration that defines this load balancer</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="at">  </span><span class="fu">lb</span><span class="kw">:</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> </span><span class="st">'dockercloud/haproxy:1.2.1'</span></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a><span class="at">    </span><span class="fu">links</span><span class="kw">:</span></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a><span class="at">     </span><span class="kw">-</span><span class="at"> app1</span></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a><span class="at">    </span><span class="fu">volumes</span><span class="kw">:</span></span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> /var/run/docker.sock:/var/run/docker.sock</span></span></code></pre></div>
<p>The trick that allows this image to listen in to our scaling of
<code>app1</code> is by passing in the docker socket as a shared volume.
Note that this particular arrangement will differ based on your host OS.
The above configuration is intended for Linux, but MacOS X users would
require a <a href="https://github.com/docker/dockercloud-haproxy#example-of-docker-composeyml-running-in-linux" class="external-link">slightly
different config</a>.</p>
<p>We could export port <code>80</code> of our new load balancer to port
<code>80</code> of our host machine if we solely wanted to load-balance
a single application. Alternatively, we can actually use both nginx (to
handle the routing of various applications) and HAProxy (to handle the
load balancing of a particular application). To do that, we’d merely add
a new <code>location</code> block to our <code>nginx.conf</code> file
that knows how to send traffic to HAProxy, or modify the existing
<code>location</code> block to send traffic to the load balancer instead
of going directly to the application.</p>
<p>So the <code>location /app1/</code> block becomes:</p>
<pre><code>location /app1/ {
  proxy_pass http://lb/;
  proxy_set_header Host $host;
}</code></pre>
<p>Where <code>lb</code> is the name of the HAProxy load balancer that
we defined in our Compose configuration.</p>
<p>The next time you start/redeploy your Docker Compose cluster, you’ll
be balancing your incoming requests to <code>/app1/</code> across a pool
of 1 or more R processes based on whatever you’ve set the
<code>scale</code> to be for that application.</p>
<p>Do keep in mind that when using load-balancing that it’s not longer
guaranteed that subsequent requests for a particular application will
land on the same process. This means that if you maintain any state in
your Plumber application (like a global counter, or a user’s session
state), you can’t expect that to be shared across the processes that the
user might encounter. There are at least three possible solutions to
this problem:</p>
<ol style="list-style-type: decimal">
<li>Use a more robust means of maintaining state. You could put the
state in a database, for instance, that lives outside of your R
processes and your Plumber processes could get and save their state
externally.</li>
<li>You could serialize the state to the user using <a href="./rendering-output.html#encrypted-cookies">(encrypted) session
cookies</a>, assuming it’s small enough. In this scenario, your workers
would write data back to the user in the form of a cookie, then the user
would include that same cookie in its subsequent requests. This works
best if the state is going to be set rarely and read often (for
instance, the cookie could be set when the user logs in, then read on
each request to detect the identity of this user).</li>
<li>You can enable “sticky sessions” in the HAProxy load balancer. This
would ensure that each user’s traffic always gets routed to the same
worker. The downside of this approach is that it will distribute traffic
less evenly. You could end up in a situation in which you have 2 R
processes for an application but 90% of your traffic is hitting one of
them if it happens the users triggering the majority of the requests are
all “stuck” to one particular worker.</li>
</ol>
</div>
</div>
<div class="section level2">
<h2 id="pm2">pm2<a class="anchor" aria-label="anchor" href="#pm2"></a>
</h2>
<p>If you don’t have the luxury of running your Plumber instance on a
designated server (as is discussed in the <a href="#digitalocean">DigitalOcean section</a>) and you’re not
comfortable hosting the API in <a href="#docker">Docker</a>, then you’ll
need to find a way to run and manage your Plumber APIs on your server
directly.</p>
<p>There are a variety of tools that were built to help manage web
hosting in a single-threaded environment like R. Some of the most
compelling tools were developed around Ruby (like <a href="https://www.phusionpassenger.com/" class="external-link">Phusion Passenger</a>) or
Node.js (like <a href="https://github.com/petruisfan/node-supervisor" class="external-link">Node
Supervisor</a>, <a href="https://github.com/foreverjs/forever" class="external-link">forever</a> or <a href="http://pm2.keymetrics.io/" class="external-link">pm2</a>). Thankfully, many of these
tools can be adapted to support managing an R process running a Plumber
API.</p>
<p><a href="http://pm2.keymetrics.io/" class="external-link">pm2</a> is a process manager
initially targeting Node.js. Here we’ll show the commands needed to do
this in Ubuntu 14.04, but you can use any Operating System or
distribution that is supported by pm2. At the end, you’ll have a server
that automatically starts your plumber services when booted, restarts
them if they ever crash, and even centralizes the logs for your plumber
services.</p>
<div class="section level3">
<h3 id="server-deployment-and-preparation">Server Deployment and Preparation<a class="anchor" aria-label="anchor" href="#server-deployment-and-preparation"></a>
</h3>
<p>The first thing you’ll need to do, regardless of which process
manager you choose, is to deploy the R files containing your plumber
applications to the server where they’ll be hosted. Keep in mind that
you’ll also need to include any supplemental R files that are
<code><a href="https://rdrr.io/r/base/source.html" class="external-link">source()</a></code>d in your plumber file, and any other datasets or
dependencies that your files have.</p>
<p>You’ll also need to make sure that the R packages you need (and the
appropriate versions) are available on the remote server. You can either
do this manually by installing those packages or you can consider using
a tool like <a href="https://rstudio.github.io/packrat/" class="external-link">Packrat</a> to
help with this.</p>
<p>There are a myriad of features in pm2 that we won’t cover here. It is
a good idea to spend some time reading through their documentation to
see which features might be of interest to you and to ensure that you
understand all the implications of how pm2 hosts services (which user
you want to run your processes as, etc.). Their <a href="http://pm2.keymetrics.io/docs/usage/quick-start/" class="external-link">quick-start
guide</a> may be especially relevant. For the sake of simplicity, we
will do a basic installation here without customizing many of those
options.</p>
</div>
<div class="section level3">
<h3 id="install-pm2">Install pm2<a class="anchor" aria-label="anchor" href="#install-pm2"></a>
</h3>
<p>Now you’re ready to install pm2. pm2 is a package that’s maintained
in <code>npm</code> (Node.js’s package management system); it also
requires Node.js in order to run. So to start you’ll want to install
Node.js. On Ubuntu 14.04, the necessary commands are:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="fu">sudo</span> apt-get update</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a><span class="fu">sudo</span> apt-get install nodejs npm</span></code></pre></div>
<p>Once you have npm and Node.js installed, you’re ready to install
pm2.</p>
<pre><code>sudo npm install -g pm2</code></pre>
<p>If you find errors like <code>SSL Error: CERT_UNTRUSTED</code> while
using <code>npm</code> command, you can bypass the ssl error using:</p>
<pre><code>npm config set strict-ssl false</code></pre>
<p>or set the registry URL from <code>https://</code> to
<code>http://</code>:</p>
<pre><code>npm config set registry="http://registry.npmjs.org/"</code></pre>
<p>This will install pm2 globally (<code>-g</code>) on your server,
meaning you should now be able to run <code>pm2 --version</code> and get
the version number of pm2 that you’ve installed.</p>
<p>In order to get pm2 to startup your services on boot, you should run
<code>sudo pm2 startup</code> which will create the necessary files for
your system to run pm2 when you boot your machine.</p>
</div>
<div class="section level3">
<h3 id="wrap-your-plumber-file">Wrap Your Plumber File<a class="anchor" aria-label="anchor" href="#wrap-your-plumber-file"></a>
</h3>
<p>Once you’ve deployed your Plumber files onto the server, you’ll still
need to tell the server <em>how</em> to run your server. You’re probably
used to running commands like</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/pr.html">pr</a></span><span class="op">(</span><span class="st">"myfile.R"</span><span class="op">)</span> <span class="op"><a href="../reference/pipe.html">%&gt;%</a></span> <span class="fu"><a href="../reference/pr_run.html">pr_run</a></span><span class="op">(</span>port<span class="op">=</span><span class="fl">4500</span><span class="op">)</span></span></code></pre></div>
<p>Unfortunately, pm2 doesn’t understand R scripts natively; however, it
is possible to specify a custom interpreter. We can use this feature to
launch an R-based wrapper for our plumber file using the
<code>Rscript</code> scripting front-end that comes with R. The
following script will run the two commands listed above.</p>
<pre><code><span><span class="co">#!/usr/bin/env Rscript</span></span>
<span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://www.rplumber.io">plumber</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/pr.html">pr</a></span><span class="op">(</span><span class="st">"myfile.R"</span><span class="op">)</span> <span class="op"><a href="../reference/pipe.html">%&gt;%</a></span></span>
<span>  <span class="fu"><a href="../reference/pr_run.html">pr_run</a></span><span class="op">(</span>port<span class="op">=</span><span class="fl">4000</span>, host<span class="op">=</span><span class="st">"0.0.0.0"</span><span class="op">)</span></span>
<span><span class="co"># Setting the host option on a VM instance ensures the application can be accessed externally.</span></span>
<span><span class="co"># (This may be only true for Linux users.)</span></span></code></pre>
<p>Save this R script on your server as something like
<code>run-myfile.R</code>. You should also make it executable by
changing the permissions on the file using a command like
<code>chmod 755 run-myfile.R</code>. You should now execute that file to
make sure that it runs the service like you expect. You should be able
to make requests to your server on the appropriate port and have the
plumber service respond. You can kill the process using
<code>Ctrl-c</code> when you’re convinced that it’s working. Make sure
the shell script is in a permanent location so that it won’t be erased
or modified accidentally. You can consider creating a designated
directory for all your plumber services in some directory like
<code>/usr/local/plumber</code>, then put all services and their
associated Rscript-runners in their own subdirectory like
<code>/usr/local/plumber/myfile/</code>.</p>
</div>
<div class="section level3">
<h3 id="introduce-our-service-to-pm2">Introduce Our Service to pm2<a class="anchor" aria-label="anchor" href="#introduce-our-service-to-pm2"></a>
</h3>
<p>We’ll now need to teach pm2 about our Plumber API so that we can put
it to work. You can register and configure any number of services with
pm2; let’s start with our <code>myfile</code> Plumber service.</p>
<p>You can use the <code>pm2 list</code> command to see which services
pm2 is already running. If you run this command now, you’ll see that pm2
doesn’t have any services that it’s in charge of. Once you have the
scripts and code stored in the directory where you want them, use the
following command to tell pm2 about your service.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="ex">pm2</span> start <span class="at">--interpreter</span><span class="op">=</span><span class="st">"Rscript"</span> /usr/local/plumber/myfile/run-myfile.R</span></code></pre></div>
<p>You should see some output about pm2 starting an instance of your
service, followed by some status information from pm2. If everything
worked properly, you’ll see that your new service has been registered
and is running. You can see this same output by executing
<code>pm2 list</code> again.</p>
<p>Once you’re happy with the pm2 services you have defined, you can use
<code>pm2 save</code> to tell pm2 to retain the set of services you have
running next time you boot the machine. All of the services you have
defined will be automatically restarted for you.</p>
<p>At this point, you have a persistent pm2 service created for your
Plumber application. This means that you can reboot your server, or find
and kill the underlying R process that your plumber application is using
and pm2 will automatically bring a new process in to replace it. This
should help guarantee that you always have a Plumber process running on
the port number you specified in the shell script. It is a good idea to
reboot the server to ensure that everything comes back the way you
expected.</p>
<p>You can repeat this process with all the plumber applications you
want to deploy, as long as you give each a unique port to run on.
Remember that you can’t have more than one service running on a single
port. And be sure to <code>pm2 save</code> every time you add services
that you want to survive a restart.</p>
<p>Run <code>netstat -tulpn</code> to see how the application is being
ran. If you see the application on host <code>127.0.0.0</code> or
<code>127.0.0.1</code>, the application cannot be accessed externally.
You should change the host parameter to <code>0.0.0.0</code>, for
example: `pr_run(host = “0.0.0.0”).</p>
</div>
<div class="section level3">
<h3 id="logs-and-management">Logs and Management<a class="anchor" aria-label="anchor" href="#logs-and-management"></a>
</h3>
<p>Now that you have your applications defined in pm2, you may want to
drill down into them to manage or debug them. If you want to see more
information, use the <code>pm2 show</code> command and specify the name
of the application from <code>pm2 list</code>. This is usually the same
as the name of the shell script you specified, so it may be something
like <code>pm2 show run-myfile</code>.</p>
<p>You can peruse this information but keep an eye on the
<code>restarts</code> count for your applications. If your application
has had to restart many times, that implies that the process is crashing
often, which is a sign that there’s a problem in your code.</p>
<p>Thankfully, pm2 automatically manages the log files from your
underlying processes. If you ever need to check the log files of a
service, you can just run <code>pm2 logs run-myfile</code>, where
<code>myfile</code> is again the name of the service obtained from
<code>pm2 list</code>. This command will show you the last few lines
logged from your process, and then begin streaming any incoming log
lines until you exit (<code>Ctrl-c</code>).</p>
<p>If you want a big-picture view of the health of your server and all
the pm2 services, you can run <code>pm2 monit</code> which will show you
a dashboard of the RAM and CPU usage of all your services.</p>
</div>
</div>
<div class="section level2">
<h2 id="systemd">systemd<a class="anchor" aria-label="anchor" href="#systemd"></a>
</h2>
<blockquote>
<p><code>systemd</code> is the service manager used by certain Linux
distributions including RedHat/CentOS 7, SUSE 12, and Ubuntu versions
16.04 and later.</p>
</blockquote>
<p>If you use a Linux server you can use <code>systemd</code> to run
Plumber as a service that can be accessed from your local network or
even outside your network depending on your firewall rules. This option
is similar to using the <a href="#docker">Docker method</a>. One of the
main advantages of using <code>systemd</code> over using Docker is that
<code>systemd</code> won’t bypass firewall rules (Docker does!) and
avoids the overhead of running a container.</p>
<p>Compared to <code><a href="../reference/digitalocean.html">plumber::do_provision()</a></code> this option won’t
create a new droplet if you use <a href="#digitalocean">DigitalOcean</a>; it will run on your existing
droplet instead.</p>
<p>To implement this option you’ll complete the following three steps
from the terminal:</p>
<ol style="list-style-type: decimal">
<li>Verify that you have the <code>plumber</code> package available
globally on the server:</li>
</ol>
<pre><code>R -e 'install.packages("plumber", repos = "https://cran.rstudio.com/")'</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>Run <code>sudo nano /etc/systemd/system/plumber-api.service</code>,
then paste and adapt this content:</li>
</ol>
<pre><code>[Unit]
Description=Plumber API
# After=postgresql
# (or mariadb, mysql, etc if you use a DB with Plumber, otherwise leave this commented)

[Service]
ExecStart=/usr/bin/Rscript -e "library(plumber); pr('/your-dir/your-api-script.R') %&gt;% pr_run(port=8080, host='0.0.0.0')"
Restart=on-abnormal
WorkingDirectory=/your-dir/

[Install]
WantedBy=multi-user.target</code></pre>
<ol start="3" style="list-style-type: decimal">
<li>Activate the service (for auto-start on power/reboot) and start
it:</li>
</ol>
<pre><code>sudo systemctl enable plumber-api  # automatically start the service when the server boots
sudo systemctl start plumber-api   # start the service right now</code></pre>
<p>To check if your API is running, type
<code>systemctl | grep running</code> in the terminal and should display
<code>plumber-api.service \ loaded active running Plumber API</code>.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



   </div>
  <footer><div class="container">
  <div class="pkgdown-footer-left">
  <p>Developed by <a href="http://schloerke.com" class="external-link">Barret Schloerke</a>, <a href="https://trestletech.com/" class="external-link">Jeff Allen</a>, <a href="https://www.posit.co" class="external-link"><img src="https://www.tidyverse.org/posit-logo.svg" alt="Posit" height="16" width="62" style="margin-bottom: 3px;"></a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

  </div></footer>
</body>
</html>
