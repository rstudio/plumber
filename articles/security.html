<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Security • plumber</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/Source_Sans_Pro-0.4.9/font.css" rel="stylesheet">
<link href="../deps/Source_Code_Pro-0.4.9/font.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Security">
</head>
<body>
    <a href="#container" class="visually-hidden-focusable">Skip to content</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-none" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">plumber</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.2.2.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/introduction.html">Introduction</a></li>
    <li><a class="dropdown-item" href="../articles/quickstart.html">Quickstart</a></li>
    <li><a class="dropdown-item" href="../articles/routing-and-input.html">Routing &amp; Input</a></li>
    <li><a class="dropdown-item" href="../articles/rendering-output.html">Rendering Output</a></li>
    <li><a class="dropdown-item" href="../articles/execution-model.html">Runtime</a></li>
    <li><a class="dropdown-item" href="../articles/security.html">Security</a></li>
    <li><a class="dropdown-item" href="../articles/hosting.html">Hosting</a></li>
    <li><a class="dropdown-item" href="../articles/programmatic-usage.html">Programmatic Usage</a></li>
    <li><a class="dropdown-item" href="../articles/annotations.html">Annotations reference</a></li>
    <li><a class="dropdown-item" href="../articles/tips-and-tricks.html">Tips &amp; Tricks</a></li>
    <li><a class="dropdown-item" href="../articles/migration.html">Migration Guide</a></li>
  </ul>
</li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-news" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">News</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-news">
<li><h6 class="dropdown-header" data-toc-skip>Releases</h6></li>
    <li><a class="external-link dropdown-item" href="https://blog.rstudio.com/2021/03/29/plumber-v1-1-0/">Version 1.1.0</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><a class="dropdown-item" href="../news/index.html">Changelog</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/rstudio/plumber/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article" id="container">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.svg" class="logo" alt=""><h1>Security</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/rstudio/plumber/blob/main/vignettes/security.Rmd" class="external-link"><code>vignettes/security.Rmd</code></a></small>
      <div class="d-none name"><code>security.Rmd</code></div>
    </div>

    
    
<p>The majority of R programmers have not been trained to give much
attention to the security of the code that they write. This is for good
reason since running R code on your own machine with no external input
gives little opportunity for attackers to leverage your R code to do
anything malicious. However, as soon as you expose an API on a network,
your concerns and thought process must adapt accordingly.</p>
<p>There are a variety of factors and attacks that you should consider
when developing your Plumber APIs, but the attention you give to each
will vary based on the audience of your API. On one extreme, if your API
is running on an internal server on your own network and uses
authentication to restrict access to only a handful of trusted users,
you may be justified in overlooking some of these attack vectors. On the
other hand, if your Plumber API is available on the Internet with no
authentication, then you should seriously consider each of these
potential vulnerabilities and convince yourself that you have properly
accounted for each.</p>
<div class="section level2">
<h2 id="networking">Networking &amp; Firewalls<a class="anchor" aria-label="anchor" href="#networking"></a>
</h2>
<p>From a networking standpoint, there are two fundamentally different
approaches for developing R code.</p>
<ol style="list-style-type: decimal">
<li>You can develop locally using a tool like <a href="https://www.rstudio.com/products/rstudio/#Desktop" class="external-link">RStudio
Desktop</a>. In this case, the R session (and any Plumber APIs that you
<code>run()</code>) will be housed on your local machine.</li>
<li>You can develop on a remote machine using a tool like <a href="https://www.rstudio.com/products/rstudio/#Server" class="external-link">RStudio
Server</a>. Here, the R session is running on a remote server accessed
across a network.</li>
</ol>
<p>In the first case, there’s typically very little to consider from a
networking perspective. Your APIs will be accessible at
<code>http://127.0.0.1:8000</code> by default (<code>localhost</code> is
synonymous with the local IP address <code>127.0.0.1</code>) and you
likely won’t need to concern yourself with firewalls or network
proxies.</p>
<p>In the second case, however, you may need to consider the network
environment in between yourself and the server running the API. These
are the same considerations you’ll need to make when hosting an API on a
server for production use. In particular, you should investigate whether
or not there are any firewalls between the server hosting the Plumber
API and the clients that you want to be able to connect.</p>
<p>Firewalls are a way to block undesired network traffic. Most desktop
computers and many servers come with firewalls enabled out-of-the-box.
This means that if you want to expose your API running on port 8000, you
will need to configure your firewall to accept incoming connections on
that port. Firewalls can also be configured on other network
intermediaries, so you may need to configure multiple firewalls to allow
traffic through in order to expose the desired port to your API
clients.</p>
</div>
<div class="section level2">
<h2 id="https">HTTPS<a class="anchor" aria-label="anchor" href="#https"></a>
</h2>
<p>HTTPS is a secure form of HTTP. Many people are now aware that they
should check that their browser displays a padlock associated with HTTPS
before they enter sensitive information like a credit card number. HTTPS
is important to consider when developing Plumber APIs, as well. HTTPS
primarily offers two protections:</p>
<ol style="list-style-type: decimal">
<li>It encrypts the information being sent between the API client and
the Plumber process using TLS (often still referred to as its
predecessor, “SSL”). This prevents others on the network from being able
to read the information being sent back and forth.</li>
<li>It gives the API client confidence that it’s communicating with your
Plumber process, as opposed to an imposter.</li>
</ol>
<p>These two assurances are critical if your API will be handling any
sensitive data or performing actions intended only for authenticated
users. Some hosting options support serving on both HTTP and HTTPS
simultaneously. The most secure configuration would be to redirect
incoming HTTP traffic to your HTTPS hosting option.</p>
<p>As an added layer of protection, you can consider enabling <a href="https://www.troyhunt.com/understanding-http-strict-transport/" class="external-link">HTTP
Strict Transport Security (HSTS)</a>. HSTS is a way to instruct clients
that – in the future – they should refuse to connect to this server over
unsecure HTTP. This ensures that no imposter server would be able to
trick a client into connecting over insecure HTTP in the future.</p>
<p>Unfortunately, Plumber does not implement HTTPS support natively, but
most of the <a href="./hosting.html">documented hosting options</a>
offer ways to deploy HTTPS and HSTS in front of your Plumber API.</p>
</div>
<div class="section level2">
<h2 id="dos">Denial Of Service (DoS)<a class="anchor" aria-label="anchor" href="#dos"></a>
</h2>
<p>Denial of service (DoS) attacks are employed in order to temporarily
shut down a server or service by overwhelming it with traffic. A DoS
scenario could be caused by a single ignorant user unintentionally
making a request that could ask the server to do some impossible task,
or could be intentionally introduced by a malicious actor leveraging a
vast number of machines to repeatedly make requests that are expensive
for the server to respond to. The later form is often called a
distributed denial of service attack (or DDoS) and typically requires
special infrastructure and network capacity that is beyond the scope of
what we’ll discuss here.</p>
<p>However, there are practices that you should employ when designing
your Plumber API to put safety guards around the work that an API
request might instigate.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#* This is an example of an UNSAFE endpoint which</span></span>
<span><span class="co">#* is vulnerable to a DOS attack.</span></span>
<span><span class="co">#* @get /</span></span>
<span><span class="co">#* @serializer png</span></span>
<span><span class="kw">function</span><span class="op">(</span><span class="va">pts</span><span class="op">=</span><span class="fl">10</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="co"># An example of an UNSAFE endpoint.</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">pts</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>The expected output here is a harmless plot.</p>
<p><img src="security_files/figure-html/unnamed-chunk-3-1.png" width="700"></p>
<p>This plot takes a negligible amount of time to create.</p>
<p>However, plots with more points will take more time to create.</p>
<p><img src="security_files/figure-html/unnamed-chunk-4-1.png" width="700"></p>
<p>This plot, with 10,000 points added, took 0.123 seconds to generate.
While that doesn’t sound like much, if we exposed this API publicly on
the Internet, an attacker could easily generate enough traffic on this
endpoint to overwhelm the Plumber process. Even worse, an attacker could
make a request on this endpoint with millions or billions of points
which might cause our server to run out of memory or consume so much CPU
that it deprives other important system resources. Either case could
result in our Plumber process crashing altogether.</p>
<p>The solution, in this case, is to ensure that we have reasonable
safety guards in place for any user input.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#* This is an example of an safe endpoint which</span></span>
<span><span class="co">#* checks user input to avoid a DOS attack</span></span>
<span><span class="co">#* @get /</span></span>
<span><span class="co">#* @serializer png</span></span>
<span><span class="kw">function</span><span class="op">(</span><span class="va">pts</span><span class="op">=</span><span class="fl">10</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="kw">if</span> <span class="op">(</span><span class="va">pts</span> <span class="op">&gt;</span> <span class="fl">1000</span> <span class="op">&amp;</span> <span class="va">pts</span> <span class="op">&gt;</span> <span class="fl">0</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/stop.html" class="external-link">stop</a></span><span class="op">(</span><span class="st">"pts must be between 1 and 1,000"</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">pts</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>Here you can see that we only allow the user to request a graph with
up to 1,000 points. Any requests exceeding that limit will immediately
be terminated without any further computation.</p>
<p>You should be very attentive to the resources that could be consumed
by any of your filters or endpoints. Consider the various values that a
user could provide for each of your API endpoint’s parameters and ensure
that the behavior of the system is reasonable in those cases. For API
endpoints that do require extensive computation, consider how you could
protect those endpoints (perhaps only exposing them for authenticated
users) to prevent a malicious user from abusing the system.</p>
</div>
<div class="section level2">
<h2 id="sanitization">Sanitization &amp; Injection<a class="anchor" aria-label="anchor" href="#sanitization"></a>
</h2>
<p>Any time you accept input from a user in your code, you should plan
for the worst-case scenario. If, for example, your API endpoint allows
the user to specify the name of a file that should be read out of a
particular directory and then returns its contents, you might naively
implement it like so.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#* This is an example of an UNSAFE endpoint which</span></span>
<span><span class="co">#* does not sanitize user input</span></span>
<span><span class="co">#* @get /</span></span>
<span><span class="kw">function</span><span class="op">(</span><span class="va">file</span><span class="op">)</span> <span class="op">{</span></span>
<span></span>
<span>  <span class="co"># An example of an UNSAFE endpoint.</span></span>
<span>  <span class="va">path</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/file.path.html" class="external-link">file.path</a></span><span class="op">(</span><span class="st">"./datasets"</span>, <span class="va">file</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/readLines.html" class="external-link">readLines</a></span><span class="op">(</span><span class="va">path</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>Unfortunately, this API endpoint does not properly sanitize the user
input. The user could set the <code>file</code> parameter to
<code>../plumber.R</code> and now the endpoint would return the source
code of your Plumber API. Of course they could just as easy attempt to
read other files that might contain API keys or other sensitive
data.</p>
<p>One solution in this case is to strip all special characters off of
the user input which will prevent users from being able to escape into a
different directory.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#* This is an example of an endpoint which</span></span>
<span><span class="co">#* checks user input.</span></span>
<span><span class="co">#* @get /</span></span>
<span><span class="kw">function</span><span class="op">(</span><span class="va">file</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="co"># Strip all "non-word" characters from user input</span></span>
<span>  <span class="va">sanitizedFile</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/grep.html" class="external-link">gsub</a></span><span class="op">(</span><span class="st">"\\W"</span>, <span class="st">""</span>, <span class="va">file</span><span class="op">)</span></span>
<span></span>
<span>  <span class="va">path</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/file.path.html" class="external-link">file.path</a></span><span class="op">(</span><span class="st">"./datasets"</span>, <span class="va">sanitizedFile</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/readLines.html" class="external-link">readLines</a></span><span class="op">(</span><span class="va">path</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>File paths are not the only opportunity for malicious input to do
damage to your system, however. Another way in which user input can be
dangerous is an attack known as “cross site scripting,” or “XSS.” This
attack can be leveraged whenever user input may be rendered in a user’s
browser. For instance if you had an endpoint which allows users to
comment on a page and then later displays those comments to other users,
an attacked could craft a comment such as:</p>
<pre><code>"This is a comment with JavaScript! &lt;script&gt;alert('I could do something bad here!');&lt;/script&gt;</code></pre>
<p>As you can see, the comment has JavaScript embedded within it, in
this case used to popup a message to the user. Of course JavaScript
could be used in other harmful way by redirecting your users to a
malicious site, for instance, or uploading data that they have special
access to on your server to some other destination. Any user input that
might be included on an HTML page should be properly escaped (see
<code>htmltools::html_escape</code> for help).</p>
<p>Lastly, user input can be used in an “injection attack,” in which the
user injects malicious commands that might be sent to another system.
The best known in this family are SQL injection attacks, in which user
input that is meant to be included in a SQL query to be executed against
a database might contain additional SQL commands that could leak data or
do damage to your database. Further details about SQL injection attacks
and mitigation strategies in R are available <a href="https://solutions.rstudio.com/db/best-practices/run-queries-safely/" class="external-link">here</a>.</p>
<p>In summary, be sure to separate “trusted” from “untrusted” objects in
your API implementation. Anything which the user provides should be
considered “untrusted” until it has been escaped or sanitized. At that
point you can consider the object to be “trusted” and proceed to take
further actions on it.</p>
</div>
<div class="section level2">
<h2 id="cross-origin-resource-sharing-cors">Cross-Origin Resource Sharing (CORS)<a class="anchor" aria-label="anchor" href="#cross-origin-resource-sharing-cors"></a>
</h2>
<p>By default, the API endpoint forbids “cross-domain” requests, but
it’s possible with a workaround to override this behavior creating a
custom function that will forward the right headers to the API using a
filter such as the following snippet.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#* @filter cors</span></span>
<span><span class="va">cors</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">res</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">res</span><span class="op">$</span><span class="fu">setHeader</span><span class="op">(</span><span class="st">"Access-Control-Allow-Origin"</span>, <span class="st">"*"</span><span class="op">)</span></span>
<span>    <span class="fu">plumber</span><span class="fu">::</span><span class="fu"><a href="../reference/forward.html">forward</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>Once this filter is defined, each endpoint will allow “cross-domain”
requests. It’s possible to disable it for some, by appending the line
<code>#* @preempt cors</code> before the declaration of a function like
this :</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#* @preempt cors</span></span>
<span><span class="co">#* @get /sub</span></span>
<span><span class="va">cors_disabled</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">a</span>, <span class="va">b</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span><span class="va">a</span><span class="op">)</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span><span class="va">b</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>Understand that, this is a temporary workaround and can constitute
critical security issues if some endpoints that shouldn’t be exposed
through <code>CORS</code> and have been enabled by default.</p>
</div>
<div class="section level2">
<h2 id="security-cookies">Cookies<a class="anchor" aria-label="anchor" href="#security-cookies"></a>
</h2>
<p>In the <a href="./rendering-output.html#setting-cookies">section on
setting cookies</a>, we discussed the mechanics of setting cookies.
However, if you intend to use cookies for any security-sensitive
purpose, you should be aware of some ways that cookies can be
exploited.</p>
<p>First and foremost, recognize that that the client has the ability to
modify or fabricate the cookies that they send to your API. So storing
preferences that the user themselves provided in a cookie is not a
concern. Storing something with security implications – like the
identity of the user making requests – however, would be; a malicious
user would just need to modify the user ID saved in their cookie in
order to trick your API into thinking that they were someone they’re
not.</p>
<p>There are two common workarounds to this concern. You can store all
session information on the server identified by long, cryptographically
random IDs and only rely on the cookie to store the ID. Or you can use
signed/encrypted cookies, as detailed in the <a href="./rendering-output.html#encrypted-cookies">section on setting
encrypted cookies</a>.</p>
<p>You should also be aware of how cookies will be handled and managed
by clients. You can manage these properties by providing different
parameters to the <code>setCookie()</code> call.</p>
<ul>
<li>
<strong>expiration</strong> - When the cookie should expire. Can
either be a <code>POSIXt</code> object that gives the time explicitly,
or a raw integer which will be interpreted as the number of seconds in
the future when this cookie should expire. If no value is provided, the
cookie will be a <code>session</code> cookie, meaning that it will
persist until the user closes the tab/browser. Remember, however, that a
client may accidentally or maliciously retain this cookie beyond its
assigned expiration time. From a security standpoint, you cannot rely on
a client to be well-behaved and to delete this cookie at the assigned
time.</li>
<li>
<strong>http</strong> - The <code>HttpOnly</code> property on a
cookie determines whether or not the cookie should be accessible to
JavaScript running on your domain. If you were using a cookie to persist
user settings and host some JavaScript that may also leverage the
preferences stored in that cookie, then you would want <code>http</code>
parameter to be <code>FALSE</code>, indicating that the cookie should
<em>not</em> be <code>HttpOnly</code>, and <em>should</em> be available
to JavaScript. If you were storing a session ID in the cookie that is
only interpretable by the server, then you should set <code>http</code>
to <code>TRUE</code>. There are a variety of attacks (such as
“cross-site scripting”) that would enable an attacker to run malicious
JavaScript on your clients’ machines, so it’s wise to limit the amount
of information accessible from JavaScript.</li>
<li>
<strong>secure</strong> - If <code>TRUE</code>, instructs clients to
only send the cookie when connecting to your server over HTTPS. HTTPS is
a mechanism by which clients can gain more assurance that the server
they’re connected to is indeed the server that they intended to be
communicating with. If your API uses HTTPS, using secure cookies
protects against a use case in which an attacker tricks one of your
clients into connecting to an HTTP server impersonating your API. In
that scenario, a client may send their cookies to this malicious server,
at which point the attacker could use those cookies on your server to
impersonate the actual user. Note that you shouldn’t enable this until
you have your API stably running HTTPS.</li>
</ul>
<p>Additionally, bear in mind that if an attacker gets physical access
to a client who has a valid cookie, the attacker could copy that cookie
off to a different machine and begin using it themselves. Unfortunately,
you can’t perfectly protect against such attacks, but you can minimize
the impact by 1.) using shorter session lifetimes (perhaps a few hours
instead of days), 2.) invalidating sessions after a period of user
inactivity, or 3.) rotating the session ID periodically; this way you’d
be able to detect that multiple clients were trying to use the same
session and could take action. You can also consider adding an
additional layer of security around very security-sensitive endpoints
(like changing a user’s password).</p>
<p>Lastly, if using encrypted cookies to store sensitive information,
you should remember that expiring a cookie is an instruction that you’re
sending to the client that may or may not be honored. Thus if you were
to set an encrypted cookie on a client to authenticate the user and that
user wishes to log out, all you can do is instruct the client that they
should delete that cookie. If the cookie had been stolen or if a
misbehaving client doesn’t delete the cookie, it’s possible that that
cookie could still be used to continue making authenticated requests to
your API.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



   </div>
  <footer><div class="container">
  <div class="pkgdown-footer-left">
  <p>Developed by <a href="http://schloerke.com" class="external-link">Barret Schloerke</a>, <a href="https://trestletech.com/" class="external-link">Jeff Allen</a>, <a href="https://www.posit.co" class="external-link"><img src="https://www.tidyverse.org/posit-logo.svg" alt="Posit" height="16" width="62" style="margin-bottom: 3px;"></a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

  </div></footer>
</body>
</html>
